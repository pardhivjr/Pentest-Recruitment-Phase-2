The executable was run.
Usage: ./crackme FLAG
The flag can be inputted to verify it.

exe was decompiled in ghidra.
decompiled code was analysed.


Analysis of decompiled code:
It checks if the given input is having length of 21 characters(0x15).
Each lettr in supersecret key is subracted by 34 and stored in abStack_28.
Initializes the abStack_28.
XOR the given input with  abStack_28.
Checks the output with local_88.


Reverse process to find the input and flag:
the values stored in abstack_28 is stored in key, the same process being done.
XOR, key and local_88
Converting the result so obtained to ASCII
appends the result to the flag.

Python program:

```def find_flag():
    key = [ord(c) - 0x22 for c in "sup3r_s3cr3t_k3y_1337"]
    local_88 = [0x37, 0x3f, 0x2f, 0x76, 0x2b, 0x62, 0x28, 0x21, 0x34, 0xf, 0x77, 0x62, 0x48, 0x27, 0x75, 8, 0x56, 0x6a, 0x68, 0x4e, 0x68]

    flag = ""
    for i in range(len(key)):
        flag_byte = key[i] ^ local_88[i]
        flag += chr(flag_byte)

    return flag


if __name__ == "__main__":
    correct_flag = find_flag()
    print(f"The correct flag is: {correct_flag}")
```


